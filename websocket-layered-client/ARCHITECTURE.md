# 分层 WebSocket 客户端架构设计

## 🎯 设计原则

### 1. 分离关注点 (Separation of Concerns)
每一层只负责特定的功能，避免职责混乱：
- **协议层**：只处理 WebSocket 协议细节
- **消息层**：只处理 JSON 消息的序列化和路由
- **业务层**：只处理应用特定的业务逻辑
- **事件层**：只处理异步事件的分发和管理

### 2. 依赖倒置 (Dependency Inversion)
高层模块不依赖低层模块，都依赖于抽象：
- 业务层通过接口调用消息层
- 消息层通过接口调用协议层
- 各层可以独立测试和替换

### 3. 开闭原则 (Open/Closed Principle)
对扩展开放，对修改关闭：
- 新增消息类型无需修改现有代码
- 新增业务逻辑通过插件机制实现
- 协议层可以支持不同的传输协议

## 🏗️ 层次架构详解

### 第一层：传输层 (Transport Layer)
```
┌─────────────────────────────────────┐
│            TQUIC/HTTP3              │
│  • QUIC 协议  • HTTP/3  • TLS 1.3   │
└─────────────────────────────────────┘
```
- **职责**：提供可靠的网络传输
- **技术**：TQUIC 库，HTTP/3 over QUIC
- **特性**：低延迟、多路复用、自动重传

### 第二层：协议层 (Protocol Layer)
```
┌─────────────────────────────────────┐
│         WebSocket Protocol          │
│  • 帧解析  • 连接管理  • 心跳检测    │
└─────────────────────────────────────┘
```
- **职责**：处理 WebSocket 协议规范
- **核心功能**：
  - WebSocket 帧的解析和构造
  - 连接状态管理（连接、断开、重连）
  - 心跳检测和超时处理
  - 掩码处理（已修复字节序问题）

### 第三层：事件系统层 (Event System Layer)
```
┌─────────────────────────────────────┐
│           Event System              │
│  • 异步事件  • 优先级队列  • 定时器  │
└─────────────────────────────────────┘
```
- **职责**：提供异步事件处理机制
- **核心功能**：
  - 事件队列管理
  - 优先级调度
  - 定时器管理
  - 线程安全的事件分发

### 第四层：消息处理层 (Message Handler Layer)
```
┌─────────────────────────────────────┐
│          Message Handler            │
│  • JSON 序列化  • 消息路由  • 队列   │
└─────────────────────────────────────┘
```
- **职责**：处理结构化消息的序列化和路由
- **核心功能**：
  - JSON 消息的序列化/反序列化
  - 消息类型路由
  - 消息队列管理
  - 超时和重试机制

### 第五层：业务逻辑层 (Business Logic Layer)
```
┌─────────────────────────────────────┐
│          Business Logic             │
│  • 业务处理  • 订阅/发布  • 认证     │
└─────────────────────────────────────┘
```
- **职责**：实现应用特定的业务逻辑
- **核心功能**：
  - 业务消息处理
  - 订阅/发布模式
  - 用户认证和授权
  - 业务状态管理

### 第六层：应用层 (Application Layer)
```
┌─────────────────────────────────────┐
│            Application              │
│  • 聊天客户端  • 数据同步  • 自定义  │
└─────────────────────────────────────┘
```
- **职责**：具体的应用实现
- **示例**：聊天客户端、实时数据同步、游戏客户端

## 📨 消息流转机制

### 发送消息流程
```
应用层 → 业务逻辑层 → 消息处理层 → 事件系统 → 协议层 → 传输层
```

1. **应用层**：调用业务 API 发送消息
2. **业务逻辑层**：构造业务消息，添加元数据
3. **消息处理层**：序列化为 JSON，加入发送队列
4. **事件系统**：异步处理发送事件
5. **协议层**：构造 WebSocket 帧
6. **传输层**：通过 QUIC 发送数据

### 接收消息流程
```
传输层 → 协议层 → 事件系统 → 消息处理层 → 业务逻辑层 → 应用层
```

1. **传输层**：接收网络数据
2. **协议层**：解析 WebSocket 帧
3. **事件系统**：分发消息接收事件
4. **消息处理层**：反序列化 JSON，路由消息
5. **业务逻辑层**：处理业务逻辑
6. **应用层**：更新 UI 或执行应用逻辑

## 🔄 事件驱动模型

### 事件类型层次
```
Generic Event
├── WebSocket Events
│   ├── Connected
│   ├── Disconnected
│   ├── Message Received
│   └── Error
├── Message Events
│   ├── Message Sent
│   ├── Message Timeout
│   └── Queue Full
├── Business Events
│   ├── Authentication
│   ├── Subscription
│   └── Notification
└── Timer Events
    ├── Heartbeat
    ├── Reconnect
    └── Cleanup
```

### 事件处理流程
1. **事件产生**：各层产生特定类型的事件
2. **事件入队**：事件进入优先级队列
3. **事件分发**：事件系统按优先级分发事件
4. **事件处理**：注册的处理器处理事件
5. **事件清理**：释放事件资源

## 🧵 线程安全设计

### 线程模型
- **主线程**：运行事件循环，处理 UI 交互
- **网络线程**：处理网络 I/O 和协议解析
- **工作线程池**：处理业务逻辑和消息序列化

### 同步机制
- **互斥锁**：保护共享数据结构
- **条件变量**：线程间通信和同步
- **原子操作**：无锁的计数器和标志位
- **读写锁**：读多写少的数据结构

## 📊 性能优化策略

### 内存管理
- **对象池**：复用频繁创建的对象
- **零拷贝**：避免不必要的数据复制
- **内存预分配**：减少动态内存分配

### 网络优化
- **批量发送**：合并小消息减少系统调用
- **压缩**：可选的消息压缩
- **连接复用**：QUIC 的多路复用特性

### 事件处理优化
- **优先级队列**：重要事件优先处理
- **批量处理**：一次处理多个事件
- **异步处理**：避免阻塞主线程

## 🔧 扩展点设计

### 消息类型扩展
```c
// 注册新的消息处理器
message_handler_register_type("custom_message", handle_custom_message);

// 实现处理函数
void handle_custom_message(const json_message_t *msg, void *user_data) {
    // 自定义处理逻辑
}
```

### 协议扩展
```c
// 支持不同的传输协议
protocol_register("websocket", &websocket_protocol_ops);
protocol_register("custom", &custom_protocol_ops);
```

### 业务逻辑扩展
```c
// 注册业务事件处理器
business_logic_register_handler("user_action", handle_user_action);
```

## 🧪 测试策略

### 单元测试
- 每一层独立测试
- Mock 依赖的下层接口
- 覆盖正常和异常情况

### 集成测试
- 层与层之间的接口测试
- 端到端的消息流转测试
- 并发和压力测试

### 性能测试
- 延迟测试
- 吞吐量测试
- 内存使用测试
- 长时间稳定性测试

## 📈 监控和诊断

### 统计信息
- 连接状态和次数
- 消息发送/接收统计
- 错误和超时统计
- 性能指标（延迟、吞吐量）

### 日志系统
- 分层日志记录
- 可配置的日志级别
- 结构化日志格式
- 日志轮转和归档

### 调试支持
- 详细的错误信息
- 状态转换跟踪
- 消息流转日志
- 性能分析工具集成

---

这个架构设计确保了代码的**可维护性**、**可扩展性**和**高性能**，为构建复杂的实时通信应用提供了坚实的基础。
